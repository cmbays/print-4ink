# Session 0218: Catalog Sync - V2 Supabase Integration

## Source & Context

**Worktree**: `~/Github/print-4ink-worktrees/session-0218-catalog-sync`
**Session Branch**: `session/0218-catalog-sync`
**Session Dates**: 2026-02-18 to 2026-02-19
**Work Type**: Feature implementation with security hardening and code review cycles
**Status**: ✅ Complete - PR #535 merged to main

This document captures the complete work done in the session/0218-catalog-sync worktree. It is intended for consolidation into the Knowledge Base by the wrap-up agent during the next cleanup phase.

---

## Summary

**Date**: 2026-02-18 to 2026-02-19
**Branch**: `session/0218-catalog-sync`
**Task**: Task 1.2 - Supabase Foundation epic (#529): V2 catalog sync - wire S&S Activewear catalog to Supabase PostgreSQL
**Status**: ✅ Complete - PR #535 merged to main

---

## Overview

Implemented full end-to-end catalog sync from S&S Activewear API to Supabase PostgreSQL, including:

- Drizzle ORM schema with numeric basePrice
- Drizzle-zod derived schemas (single source of truth)
- Supabase provider with Zod validation on all queries
- Admin API endpoint with security hardening
- Full pagination (50K+ styles support)
- Batched inserts for performance and safety
- RLS enabled with public read / service_role write policies

---

## Key Implementations

### 1. Database Layer

- **File**: `src/db/schema/catalog.ts`
- **Details**: Drizzle pgTable with 10 columns:
  - `id` (varchar, PK): Supplier style ID (non-UUID, numeric like "3001")
  - `brand`, `sku`, `name`: Supplier metadata
  - `baseCategory`: Enum-validated garment type
  - `basePrice`: Numeric mode for type safety (not string)
  - `availableColors`, `availableSizes`: JSONB arrays
  - `isEnabled`, `isFavorite`: User-curated fields (preserved on sync)
  - `updatedAt`: Sync timestamp

### 2. Schema & Validation

- **File**: `src/domain/entities/garment.ts`
- **Approach**: Drizzle-zod derivation (single source of truth)
  - `garmentCatalogSchema`: createSelectSchema(catalog) + .extend() with stricter validators
  - `newGarmentCatalogSchema`: createInsertSchema for batch upserts
  - Validation rules:
    - Strings: min(1) for brand/sku/name
    - baseCategory: enum validation (t-shirts, fleece, outerwear, pants, headwear)
    - basePrice: nonnegative()

### 3. Supabase Provider

- **File**: `src/infrastructure/repositories/_providers/supabase/garments.ts`
- **Functions**:
  - `getGarmentCatalog()`: Returns enabled garments only, validates through Zod
  - `getGarmentById(id)`: Validates ID format (min 1, max 50 chars) per CLAUDE.md rule #9
  - `getAvailableBrands()`: Distinct brands from enabled garments only (consistency fix)
- **Key Pattern**: All queries parse results through Zod schema instead of unsafe type casting

### 4. Catalog Sync Service

- **File**: `src/infrastructure/services/catalog-sync.service.ts`
- **Flow**:
  1. Fetch all styles from supplier adapter with full pagination
  2. Map CanonicalStyle → GarmentCatalog (filter nulls)
  3. Batch insert into Supabase (1000 rows/batch)
  4. Upsert with EXCLUDED pseudo-table (not column references)
  5. Preserve user fields (isEnabled, isFavorite) on conflict
- **Pagination Safety**:
  - Loop until hasMore=false or MAX_CATALOG_PAGES (500)
  - Zero-progress guard prevents infinite loops
- **Batching**:
  - ~1000 rows per batch (safe for 65535 PostgreSQL parameter limit)
  - Logs progress per batch

### 5. API Endpoint

- **File**: `src/app/api/catalog/sync/route.ts`
- **Security Hardening**:
  - Timing-safe comparison: `crypto.timingSafeEqual` (prevents timing attacks)
  - Explicit ADMIN_SECRET guard: returns 500 if env var missing
  - Header validation: x-admin-secret required
- **Response**: `{ synced: number, timestamp: ISO string }` or error codes (401, 500)

### 6. Router & Module Boundaries

- **File**: `src/infrastructure/repositories/garments.ts`
- **Pattern**: Dynamic imports for server-only modules
  - Defers Supabase provider import until runtime
  - Prevents bundling into client code
- **Routing Order**:
  1. Check isSupabaseCatalogMode() → use Supabase provider
  2. Check isSupplierMode() → use S&S adapter
  3. Default → use mock provider

### 7. Database Migrations

- **File**: `supabase/migrations/0000_clever_salo.sql`
  - Initial catalog table creation (auto-generated by Drizzle)
- **File**: `supabase/migrations/0001_enable_rls_catalog.sql`
  - Enable RLS on catalog table
  - CREATE POLICY for public read (everyone)
  - CREATE POLICY for service_role write (server-side sync only)

---

## Code Review & Fixes

### Round 1: Initial Review Found 11 Issues

**Critical (2)**:

1. Upsert no-op bug: Column references resolved to existing values instead of EXCLUDED
   - **Fix**: Use `sql\`excluded.column_name\`` with snake_case PostgreSQL names
2. Single-page sync: Only fetched first 100 styles
   - **Fix**: Implement full pagination loop with hasMore check

**Major (4)**: 3. Timing-unsafe secret comparison (`===`)

- **Fix**: Use `crypto.timingSafeEqual` with length pre-check

4. Missing ADMIN_SECRET guard
   - **Fix**: Return 500 if env var not configured
5. RLS disabled on catalog table
   - **Fix**: New migration enables RLS with proper policies
6. Unsafe type casting in Supabase provider
   - **Fix**: Parse all query results through Zod schema
   - **Also**: Add ID validation to getGarmentById (CLAUDE.md rule #9)

**Warnings (5)**: 7. Misleading isSupplierMode() includes 'supabase-catalog' 8. getGarmentCatalogMutable exported from server-only module 9. Dead file: \_providers/mock/phase1-garments.ts (no consumers) 10. No test coverage for catalog-sync.service.ts 11. Redundant .refine() on schema (removed)

### Round 2: After Fixes, Found 2 More Issues

**Major (2)**:

1. User field overwrite: isEnabled/isFavorite reset on every sync
   - **Fix**: Exclude from onConflictDoUpdate set clause (preserve user values)
2. No batching on bulk insert: Could exceed PostgreSQL parameter limit (65535)
   - **Fix**: Batch inserts into ~1000 row chunks

**Warnings (2)**: 3. getAvailableBrands() inconsistent: Returns all brands, not just enabled ones

- **Fix**: Add `.where(eq(catalog.isEnabled, true))` filter

**Final Decision**: PASS (all critical and major issues fixed)

---

## Testing & Quality Gates

### Test Results

- ✅ All 1388 tests passing (60 test files)
- ✅ No new test failures introduced
- ✅ Coverage thresholds maintained
  - Money helpers: 100%
  - Pricing service: 100%
  - Domain rules: 90%
  - Repositories: 80%
  - Overall: 70%

### Build & Type Safety

- ✅ `npm run build` succeeds (production build)
- ✅ `npx tsc --noEmit` passes (no type errors)
- ✅ `npm run lint` passes (ESLint clean)
- ✅ Pre-commit hooks passed (eslint --fix, prettier --write)

### CI Checks

- ✅ CodeRabbit review (passed)
- ✅ GitHub CI check (passed, 3m29s)
- ✅ PR labeler (passed, 6s)

---

## Architecture Decisions

### Why Drizzle-zod Derivation?

**Problem**: Hand-written Zod schemas can drift from database column types, causing validation bypass.
**Solution**: Derive Zod schemas from Drizzle table definition using `createSelectSchema()` + `.extend()`. Single source of truth.
**Trade-off**: Schema changes require one-step update (add column to Drizzle, re-run build).

### Why Numeric basePrice?

**Problem**: JavaScript floating-point arithmetic (IEEE 754) causes silent errors on monetary values.
**Solution**: Drizzle `mode: 'number'` stores as PostgreSQL `numeric` type (arbitrary precision) and parses as JS number.
**Constraint**: CLAUDE.md #9 requires `big.js` for arithmetic — this schema enforces type safety at DB boundary.

### Why Batched Inserts?

**Problem**: Inserting 50,000+ rows in a single query generates 500,000+ PostgreSQL parameters (11 columns × rows), exceeding the 65535 limit.
**Solution**: Batch into ~1000 row chunks, each within parameter limit.
**Performance**: Single large query vs. many small queries trades latency for throughput safety. Acceptable for hourly/daily sync.

### Why Preserve User Fields?

**Problem**: First sync sets isEnabled=true, isFavorite=false. If user disables a garment, next sync resets it.
**Solution**: Exclude isEnabled and isFavorite from onConflictDoUpdate, preserving user customizations.
**Assumption**: User field changes (enable/disable) are infrequent and intentional; supplier data changes (brand, price) are frequent and authoritative.

### Why Dynamic Imports for Supabase Provider?

**Problem**: Supabase provider imports `db` which requires `DATABASE_URL`. Next.js tries to bundle it into client code at build time.
**Solution**: Defer import to runtime with dynamic `await import()`.
**Pattern**: Matches existing garments repository dynamic import for supabase-catalog mode.

---

## Known Limitations & Warnings

### Deferred (Non-blocking)

1. **Rate limiting**: No guard against concurrent POST /api/catalog/sync requests. Concurrent syncs could overwhelm supplier API and database.
   - **Mitigation**: Simple in-memory mutex or timestamp guard can be added in Phase 2.
   - **Production mitigation**: Database advisory lock recommended.

2. **Dead code**: `newGarmentCatalogSchema` and `_providers/mock/phase1-garments.ts` unused.
   - **Action**: Can be removed in cleanup task, or kept for future bulk operations.

3. **isSupplierMode() unclear**: Returns true for any SUPPLIER_ADAPTER value including 'supabase-catalog'.
   - **Mitigation**: Routing works because isSupabaseCatalogMode() is checked first. Noted for future clarity improvement.

---

## Files Modified/Created

### New Files

- `src/db/schema/catalog.ts` — Drizzle table definition
- `src/infrastructure/repositories/_providers/supabase/garments.ts` — Supabase provider
- `src/infrastructure/repositories/garments-phase1.ts` — Phase 1 client exports
- `src/infrastructure/services/catalog-sync.service.ts` — Sync service with pagination & batching
- `src/app/api/catalog/sync/route.ts` — Admin sync endpoint
- `supabase/migrations/0000_clever_salo.sql` — Initial schema (auto-generated)
- `supabase/migrations/0001_enable_rls_catalog.sql` — RLS policies
- `supabase/migrations/meta/` — Migration metadata (auto-generated)

### Modified Files

- `src/domain/entities/garment.ts` — Schema refactoring (drizzle-zod derivation)
- `src/infrastructure/repositories/garments.ts` — Router with dynamic imports
- `src/infrastructure/repositories/_providers/supplier/garments.ts` — Added updatedAt field
- `src/infrastructure/repositories/_providers/mock/data.ts` — Updated mock data with updatedAt
- `src/infrastructure/repositories/__tests__/garments.test.ts` — Added supabase-catalog tests
- `src/domain/entities/__tests__/garment.test.ts` — Updated test data
- `src/app/(dashboard)/garments/_components/BrandDetailDrawer.tsx` — Import from garments-phase1
- `src/app/(dashboard)/jobs/_components/JobDetailsSection.tsx` — Import from garments-phase1
- `src/app/(dashboard)/jobs/board/_components/ProductionBoard.tsx` — Import from garments-phase1
- `tsconfig.json` — Added @db path alias
- `vitest.config.ts` — Added @db path alias

---

## Commits

1. **df0fcfe** - `feat(catalog): V2 sync - wire S&S Activewear catalog to Supabase PostgreSQL`
   - Initial implementation with full feature set

2. **b4b349b** - `fix(catalog): critical security and functionality improvements`
   - Fixed upsert no-op, single-page sync, timing-safe auth, RLS, unsafe casting, ID validation

3. **4d76096** - `fix(catalog): preserve user fields and add batch insert safety`
   - Preserved isEnabled/isFavorite, added batched inserts, consistent brand filtering

---

## Next Steps / Future Work

1. **Rate limiting** (Phase 2)
   - Add in-memory mutex or timestamp guard to /api/catalog/sync
   - Consider database advisory locks for production

2. **Periodic sync job** (Phase 2)
   - Scheduled catalog sync (e.g., hourly or daily)
   - Webhook from S&S Activewear when catalog changes

3. **Test coverage** (Phase 2)
   - Add unit tests for catalog-sync.service.ts
   - Add E2E tests for full sync flow

4. **Dead code cleanup** (Phase 2)
   - Remove unused newGarmentCatalogSchema if not needed
   - Remove unused \_providers/mock/phase1-garments.ts

5. **Schema improvements** (Phase 3+)
   - Add indexes on isEnabled, brand columns
   - Consider partitioning by baseCategory for large catalogs

---

## Session Metadata

- **Branch**: `session/0218-catalog-sync`
- **PR**: #535 (merged)
- **Epic**: #529 (Supabase + Drizzle foundation)
- **Related PR**: #534 (Wave 0 foundation)
- **Tests**: 1388 passing, 0 failing
- **Build**: Clean
- **Type safety**: Verified
- **Code review**: Passed (2 passes, all issues fixed)
